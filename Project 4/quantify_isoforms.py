
import argparse
import zipfile
import numpy as np
from sklearn.linear_model import ElasticNet
from sklearn.datasets import make_regression
from collections import defaultdict
import time

def parse_annotation_file(annotation_fn):
	"""
	:param annotation_fn: the gene annotations file
	:return: outputs a list of tuples, "genes". Every tuple represents one gene, the first element of the tuple is the
			list of exon index ranges for that gene, the second element of the tuple is the list of isoforms that exist
			for that gene. For example, genes[0][0][0] references the first exon range of the first gene (in a tuple),
			genes[2][1][3] references the fourth isoform of the third gene.
	"""

	with open(annotation_fn, 'r') as aFile:
		N = int(aFile.readline().strip())
		genes = [None]*N
		for i in range(N):
			numExons = int(aFile.readline().strip())
			exons = [None]*numExons
			starts = [int(x) for x in aFile.readline().strip().split(' ')]
			ends = [int(x) for x in aFile.readline().strip().split(' ')]
			for j in range(numExons):
				exons[j] = (starts[j], ends[j])
			numIsoforms = int(aFile.readline().strip())
			isoforms = [None]*numIsoforms
			for j in range(numIsoforms):
				isoforms[j] = [int(x) for x in aFile.readline().strip().split(' ')]
			genes[i] = (exons, isoforms)
		# print(genes)
	return genes


def parse_genome_file(genome_fn):
	"""
	:param genome_fn: the full genome file
	:return: the string containing the genome
	"""

	with open(genome_fn, 'r') as gFile:
		# print(gFile.readline().strip())
		return gFile.readline().strip()


def parse_reads_file(reads_fn):
	"""
	:param reads_fn: the file of shuffled reads
	:return: a list containing all of the shuffled reads
	"""
	
	out_reads = []
	with open(reads_fn, 'r') as rFile:
		for line in rFile:
			out_reads.append(line.strip())
	# print(out_reads)
	return out_reads

def make_exome_hash(exome, key_length):
	"""

	:param exome: The exome as a string stored
	:param key_length: The length of keys to use.
	:return: a dictionary of k-mers with associated exome #
	"""
	exome_hash = defaultdict(list)
	for i in range(len(exome)):
		for j in range(len(exome[i]) - key_length):
			ref_piece = exome[i][j: j+key_length]
			exome_hash[ref_piece].append(i)
	return exome_hash

def align_reads(exome_hash, read):
	"""
	Uses hashing to identify the set of locations spanned by
	a read.

	:param read: A single read
	:param exome_hash: A hash of the genome with uniform key length
	:return:
	"""
	if read in exome_hash:
		return exome_hash[read]
	return -1

def align_short_reads(exome_hash, read, key_length):
	# """
	# print(len(read))
	# key_length = max(map(len, exome_hash))
	read_pieces = [read[i * key_length: (i + 1) * key_length] for i in range(len(read) // key_length)]
	# print(read_pieces)
	# # print(exome_hash)
	# for read_piece in read_pieces:
	# 	if read in exome_hash:
	# 		print(exome_hash[read])
	# input("press10")
	hashed_read_locations = [exome_hash[read_piece] for read_piece in read_pieces]
	# print(hashed_read_locations)						 
	consensus = {}
	for i in range(len(hashed_read_locations)):
		for j in range(len(hashed_read_locations[i])):
			if hashed_read_locations[i][j] in consensus:
				consensus[hashed_read_locations[i][j]] += 1
			else:
				consensus[hashed_read_locations[i][j]] = 1
	
	if not consensus: # empty dictionary
		return -1

	best = max(consensus.keys(), key=(lambda key: consensus[key]))
	print("aligned <50", best)
	return best
	# """

# for short reads, dictionary does not work so use sliding window instead
"""
def align_short_reads(exome, read):
	for i in range(len(exome)):
			exon = exome[i]
			for j in range(len(exon) - len(read)):
				for k in range(len(read)):
					if (read[k] != exon[k+j]): #mismatch then continue to next pos
						break
					elif(read[k] == exon[k+j] and k == len(read)-1): #until the pos where all nuclotides match
						print(i, read, exon[j:j+k])
						return i #return the specific exon
	return -1
"""

def linear_regression(X, y):
	if len(X) < 1: # if X has a dimension of 0 then return 0 for coverages
		return np.zeros((len(X),), dtype=float)
	regr = ElasticNet(random_state=0)
	regr.fit(X, y)  
	ElasticNet(alpha=1.5, positive=True)
	return regr.coef_

def quantify_isoforms(genes, genome, reads):
	"""
	:param genes: the list of gene tuples generated by the parser
	:param genome_fn: the full genome file
	:param reads_fn: the file of shuffled reads
	:return: a list of tuples, where the first element of the tuple is the transcript sequence (the isoform in terms of
			the exon sequences that form it in the genome), and the second element of the tuple is the abundance of that
			specific isoform
			NOTE: this skeleton is built assuming the return value exists like this, but as long as you change the way
			the output file is generated, this can be in whatever form you like.
	"""


# Step 1: Generate Exome
	exome = [] # a "genome" consisting of individual exons
	gene_num_exon = [] # keeping track of the start exon index for each gene
	count_exon = 0 # keeping track of total num of exons all genes have
	for i in range(len(genes)):
		for j in range(len(genes[i][0])):
			exome.append(genome[genes[i][0][j][0]:genes[i][0][j][1]+1])
		gene_num_exon.append(count_exon) # start isoform for each gene
		count_exon += len(genes[i][0])
	exome_hash = make_exome_hash(exome, 50) # hash the exome: keylength = 50
	exome_hash_short = make_exome_hash(exome, 20) # hash the exome: keylength = 20
	# print("exome hash_short:", exome_hash_short)
	# print("exome:", exome)
	# print(gene_num_exon)
	exonL_readL = [] # exon length / read length (e.g. 500/50)
	for i in range(len(exome)):
		exonL_readL.append(float(len(exome[i]))/50) # need to CHANGE this to have -49 if junctions
	print(exonL_readL)

# Step 2: Generate Transcriptome & Junction-Genome
	junction_genome = [] # a "genome" of junctions
	transcriptome = [] # transcriptome consisting of all isoforms

	gene_num_isoform = [] # keeping track of the start isoform index for each gene
	gene_num_junction = [] # keeping track of the num of different junctions each gene has, and the start junction index
	isoform_junction = [] # keeping track of the list of junctions each isoform has

	count_isoform = 0 # keeping track of total num of isoforms all genes have
	count_junction = 0 # keeping track of total num of different junctions all genes have
	prev_count_junction = 0

	# generate transcriptome & junction-genome
	for i in range(len(genes)): # go through each gene (e.g. 1-5)
		for isoform in range(len(genes[i][1])): # go through each isoform of gene i: e.g. [0, 1, 3]
			temp_isoform = ""
			isoform_junction.append([])
			prev_k = -1
			for index in range(len(genes[i][1][isoform])): # go through each index in the isoform
				k = genes[i][1][isoform][index] # the num in the isoform (different from index)
				temp_isoform += exome[gene_num_exon[i]+k]
				if index >= 1:
					temp_junction = exome[gene_num_exon[i]+prev_k][max(0,len(exome[gene_num_exon[i]+prev_k])-49):]+exome[gene_num_exon[i]+k][:min(49,len(exome[gene_num_exon[i]+k]))]
					if temp_junction not in junction_genome:
						junction_genome.append(temp_junction)
						isoform_junction[isoform+count_isoform].append(len(junction_genome)-1)
						count_junction += 1
					else: # if already in junction_genome, append the index
						isoform_junction[isoform+count_isoform].append(junction_genome.index(temp_junction))
					print("gene:", i, "isoform:", isoform, "exon:", k, "junc-index:", isoform_junction[isoform][-1], "junction:", temp_junction)
				# junction: the last 49 of prev exon and the first 49 of next exon
				prev_k = k
			transcriptome.append(temp_isoform)
		# gene_num_isoform.append((count_isoform, count_isoform+len(genes[i][1])-1)) # tuple of *inclusive* (start, end) isoforms for each gene
		gene_num_isoform.append(count_isoform) # start isoform for each gene
		gene_num_junction.append((count_junction-prev_count_junction, prev_count_junction)) # tuple of (num of distinct junctions, start junction index) for each gene
		prev_count_junction = count_junction
		count_isoform += len(genes[i][1])
	junction_hash = make_exome_hash(junction_genome, 50) # hash the junction_genome: keylength = 50
	junction_hash_short = make_exome_hash(junction_genome, 20) # hash the junction_genome: keylength = 20
	# print("junc-genome:", junction_genome)
	# print("isoform-junction:", isoform_junction)
	# print("gene_num_junction:", gene_num_junction)
	# print("gene_num_isoform:", gene_num_isoform)
	junctionL_readL = [] # exon length / read length (e.g. 500/50)
	for i in range(len(junction_genome)):
		junctionL_readL.append(float(len(junction_genome[i]))/50) # need to CHANGE this to have -49 if junctions?????????
	print(junctionL_readL)
	# print("transcriptome:", transcriptome)
	# print(count_isoform)
	# print(gene_num_isoform)

# Step 3: Align Reads to Exome & Junction_Genome
	# use hash table to align the reads (no mismatch allowed) and summarize the counts
	exon_count = np.zeros((len(exome),), dtype=int)
	junction_count = np.zeros((len(junction_genome),), dtype=int)
	COUNT = 0
	COUNT_below50 = 0
	# for read in reads:
	for i in range(len(reads)):
		read = reads[i]
		if COUNT%100000 == 0 and COUNT != 0:
			print("progress:", float(i)/2000018, "%")
			# print("EXON:",exon_count)
			# time display => progress report
			time_passed = (time.process_time())/60
			print('{} reads aligned'.format(COUNT), 'in {:.3} minutes'.format(time_passed))
			remaining_time = time_passed/COUNT*(len(reads)-COUNT)
			print('Approximately {:.3} minutes remaining'.format(remaining_time))
        # end progress report
		COUNT += 1
		# print(len(read))
		if len(read) < 50:
			COUNT_below50 += 1
		 	# print("<50")
			# aligned_exon = align_short_reads(exome_hash_short, read, 20)
			# aligned_junction = align_short_reads(junction_hash_short, read, 20)
		else:
			aligned_exon = align_reads(exome_hash, read)
			aligned_junction = align_reads(junction_hash, read)
		if aligned_exon != -1:
			exon_count[aligned_exon] += 1
		if aligned_junction != -1:
			junction_count[aligned_junction] += 1
	print("TOTAL EXON:",exon_count)
	print("TOTAL JUNCTION:",junction_count)
	print("COUNT_below50:", COUNT_below50)

# Step 4: Generate & Solve Matrix for Abundance
	# construct a matrix for each gene, and compute isoform abundances
	isoform_abundance = []
	for i in range(len(gene_num_isoform)): # go through each gene
		isoform_Matrix = [[0 for m in range(len(genes[i][0])+gene_num_junction[i][0])] for n in range(len(genes[i][1]))]
		# outer loop: isoforms
			# inner loop: exons
		for a in range(len(isoform_Matrix)): # all isoforms
			for exon in genes[i][1][a]: #each exon in each isoform
				isoform_Matrix[a][exon] = exonL_readL[gene_num_exon[i]+exon]
		for b in range(len(isoform_Matrix)): # all isoforms in gene i, indices are (gene_num_junction[i]+b)
			for junction in isoform_junction[gene_num_isoform[i]+b]: # each junction in each isoform
				isoform_Matrix[b][len(genes[i][0])+junction-gene_num_junction[i][1]] = junctionL_readL[junction]
		# print(isoform_Matrix)

		# perform least-square:
		X = (np.matrix(isoform_Matrix)).T # isoform_Matrix is actually a transpose of what we learned in class: #isoform * #exon
		y = exon_count[gene_num_exon[i]:gene_num_exon[i]+len(genes[i][0])]
		y = np.append(y, junction_count[gene_num_junction[i][1]:gene_num_junction[i][1]+gene_num_junction[i][0]])
		y = (np.array([y])).T

		# coverage = ((X.T*X).I)*(X.T)*y
		coverage = linear_regression(X, y)

		# print(sum(coverage))
		abundance = [b/sum(coverage) for b in coverage]
		# print(abundance)
		for c in range(len(abundance)):
			isoform_abundance.append((transcriptome[gene_num_isoform[i]+c], abundance[c]))

	return isoform_abundance


if __name__ == "__main__":
	"""
	For an example of how you might call this script to run on the data provided:
	
	Usage: python proj4.py -g full_genome.txt -r shuffled_reads.txt -a DATA_PA_1100_0 -o test.out -t hw4_r_4_chr_1
	"""

	# parser = argparse.ArgumentParser(description='For now this starter code helps parse the files given, but leaves\n'
	#                                              'the actual function that must be implemented empty')
	# parser.add_argument('-g', '--genome', required=True, dest='genome_file', help='File containing the full genome')
	# parser.add_argument('-r', '--reads', required=True, dest='read_file', help='File containing the shuffled reads')
	# parser.add_argument('-a', '--annotation', required=True, dest='annotation_file', help='File containing gene '
	#                                                                                       'annotations')
	# parser.add_argument('-o', '--outputFile', required=True, dest='output_file', help='Output file name')
	# parser.add_argument('-t', '--outputHeader', required=True, dest='output_header',
	#                     help='String that needs to be output on the first line of the output file so that the online\n'
	#                          'submission system recognizes which leaderboard this file should be submitted to. For\n'
	#                          'hw4, this will be hw4_r_4_chr_1')

	# args = parser.parse_args()
	# genome_fn = args.genome_file
	# reads_fn = args.read_file
	# annotation_fn = args.annotation_file
	# output_fn = args.output_file

	genome_fn = "full_genome.txt"
	reads_fn = "shuffled_reads.txt"
	annotation_fn = "DATA_PA_1100_0"
	# annotation_fn = "DATA_PA_5_1100_1"
	# annotation_fn = "DATA_PA_5_1100_2"
	output_fn = "test.out"
	output_header = "hw4_r_4_chr_1"
	# output_header = "hw5_r_5_chr_1"
	# output_header = "hw5_r_5_chr_2"

	genes = parse_annotation_file(annotation_fn)
	genome = parse_genome_file(genome_fn)
	reads = parse_reads_file(reads_fn)
	print(len(reads))
	output = quantify_isoforms(genes, genome, reads)
	with open(output_fn, 'w') as oFile:
		# oFile.write('>' + args.output_header + '\n')
		oFile.write('>' + output_header + '\n')
		oFile.write('>RNA\n')
		for isoform in output:
			out_str = '{} {}\n'.format(isoform[0], isoform[1])
			oFile.write(out_str)

	zip_fn = output_fn + '.zip'
	with zipfile.ZipFile(zip_fn, 'w') as zFile:
		zFile.write(output_fn)